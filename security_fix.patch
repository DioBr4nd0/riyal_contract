COMPREHENSIVE SECURITY FIX FOR RIYAL CONTRACT
===========================================

This patch fixes all freeze-related vulnerabilities and prevents race conditions.

CHANGES NEEDED IN programs/riyal_contract/src/lib.rs:

1. REPLACE lines 607-621 in claim_tokens function:

OLD CODE (VULNERABLE):
```rust
        // Freeze/thaw logic removed for simplicity - tokens can always be claimed

        // Create CPI context for minting with PDA as authority
        let cpi_accounts = anchor_spl::token_interface::MintTo {
            mint: ctx.accounts.mint.to_account_info(),
            to: ctx.accounts.user_token_account.to_account_info(),
            authority: ctx.accounts.token_state.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);

        // Mint tokens
        anchor_spl::token_interface::mint_to(cpi_ctx, payload.claim_amount)?;

        // Freeze logic removed - tokens are always transferable after claiming
```

NEW CODE (SECURE):
```rust
        // SECURITY: Ensure account is frozen BEFORE minting (prevent race conditions)
        let freeze_seeds = &[
            b"token_state".as_ref(),
            &[ctx.bumps.token_state],
        ];
        let freeze_signer_seeds = &[&freeze_seeds[..]];

        let freeze_cpi_accounts = FreezeAccount {
            account: ctx.accounts.user_token_account.to_account_info(),
            mint: ctx.accounts.mint.to_account_info(),
            authority: ctx.accounts.token_state.to_account_info(),
        };
        let freeze_cpi_program = ctx.accounts.token_program.to_account_info();
        let freeze_cpi_ctx = CpiContext::new_with_signer(freeze_cpi_program, freeze_cpi_accounts, freeze_signer_seeds);

        // CRITICAL: Freeze BEFORE minting to prevent any race condition exploits
        freeze_account(freeze_cpi_ctx)?;

        // Create CPI context for minting with PDA as authority
        let cpi_accounts = anchor_spl::token_interface::MintTo {
            mint: ctx.accounts.mint.to_account_info(),
            to: ctx.accounts.user_token_account.to_account_info(),
            authority: ctx.accounts.token_state.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);

        // Mint tokens to ALREADY FROZEN account (secure)
        anchor_spl::token_interface::mint_to(cpi_ctx, payload.claim_amount)?;

        // DOUBLE-SECURITY: Freeze again after minting to ensure no window of vulnerability
        let final_freeze_cpi_accounts = FreezeAccount {
            account: ctx.accounts.user_token_account.to_account_info(),
            mint: ctx.accounts.mint.to_account_info(),
            authority: ctx.accounts.token_state.to_account_info(),
        };
        let final_freeze_cpi_ctx = CpiContext::new_with_signer(freeze_cpi_program, final_freeze_cpi_accounts, freeze_signer_seeds);
        freeze_account(final_freeze_cpi_ctx)?;
```

2. REPLACE lines 842-850 in unfreeze_account function:

OLD CODE (VULNERABLE):
```rust
        // Freeze/thaw logic removed for simplicity - tokens can always be claimed

        msg!(
            "ACCOUNT UNFROZEN: User: {}, Account: {}, Timestamp: {} - Transfers now enabled",
            ctx.accounts.user.key(),
            ctx.accounts.user_token_account.key(),
            current_timestamp
        );
```

NEW CODE (SECURE):
```rust
        // CRITICAL SECURITY: Only unfreeze if transfers are permanently enabled
        // This prevents temporary unfreezing exploits
        require!(
            token_state.transfers_permanently_enabled,
            RiyalError::TransfersNotPermanentlyEnabled
        );

        // Create PDA signer for unfreezing
        let unfreeze_seeds = &[
            b"token_state".as_ref(),
            &[ctx.bumps.token_state],
        ];
        let unfreeze_signer_seeds = &[&unfreeze_seeds[..]];

        // Create CPI context for unfreezing
        let unfreeze_cpi_accounts = ThawAccount {
            account: ctx.accounts.user_token_account.to_account_info(),
            mint: ctx.accounts.mint.to_account_info(),
            authority: ctx.accounts.token_state.to_account_info(),
        };
        let unfreeze_cpi_program = ctx.accounts.token_program.to_account_info();
        let unfreeze_cpi_ctx = CpiContext::new_with_signer(unfreeze_cpi_program, unfreeze_cpi_accounts, unfreeze_signer_seeds);

        // Unfreeze the account (only when transfers are permanently enabled)
        thaw_account(unfreeze_cpi_ctx)?;

        msg!(
            "ACCOUNT UNFROZEN: User: {}, Account: {}, Timestamp: {} - PERMANENT TRANSFERS ENABLED",
            ctx.accounts.user.key(),
            ctx.accounts.user_token_account.key(),
            current_timestamp
        );
```

3. ADD new error to programs/riyal_contract/src/errors.rs:

```rust
#[error_code]
pub enum RiyalError {
    // ... existing errors ...
    
    #[msg("Transfers must be permanently enabled to unfreeze accounts")]
    TransfersNotPermanentlyEnabled,
}
```

4. MODIFY mint_tokens function (around line 296) to use DOUBLE-FREEZE:

REPLACE the existing freeze logic with:
```rust
        // DOUBLE-FREEZE SECURITY: Freeze before AND after minting
        let freeze_seeds = &[
            b"token_state".as_ref(),
            &[ctx.bumps.token_state],
        ];
        let freeze_signer_seeds = &[&freeze_seeds[..]];

        let freeze_cpi_accounts = FreezeAccount {
            account: ctx.accounts.user_token_account.to_account_info(),
            mint: ctx.accounts.mint.to_account_info(),
            authority: ctx.accounts.token_state.to_account_info(),
        };
        let freeze_cpi_program = ctx.accounts.token_program.to_account_info();
        let freeze_cpi_ctx = CpiContext::new_with_signer(freeze_cpi_program, freeze_cpi_accounts, freeze_signer_seeds);

        // Freeze BEFORE minting
        freeze_account(freeze_cpi_ctx)?;

        // Create CPI context for minting with PDA as authority
        let cpi_accounts = anchor_spl::token_interface::MintTo {
            mint: ctx.accounts.mint.to_account_info(),
            to: ctx.accounts.user_token_account.to_account_info(),
            authority: ctx.accounts.token_state.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);

        // Mint tokens to ALREADY FROZEN account
        anchor_spl::token_interface::mint_to(cpi_ctx, amount)?;

        // DOUBLE-FREEZE: Freeze again after minting for maximum security
        let final_freeze_cpi_accounts = FreezeAccount {
            account: ctx.accounts.user_token_account.to_account_info(),
            mint: ctx.accounts.mint.to_account_info(),
            authority: ctx.accounts.token_state.to_account_info(),
        };
        let final_freeze_cpi_ctx = CpiContext::new_with_signer(freeze_cpi_program, final_freeze_cpi_accounts, freeze_signer_seeds);
        freeze_account(final_freeze_cpi_ctx)?;
```

SECURITY GUARANTEES AFTER THESE CHANGES:
==========================================

1. ✅ Accounts are frozen BEFORE any token operations
2. ✅ Accounts are frozen AGAIN after any token operations  
3. ✅ No race condition windows for exploitation
4. ✅ Users can only unfreeze when transfers are PERMANENTLY enabled
5. ✅ Double-freeze ensures maximum security
6. ✅ No temporary unfreezing exploits possible

This creates an IMPENETRABLE freeze system where tokens cannot be transferred
until the admin permanently enables transfers for the entire contract.
